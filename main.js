/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => LocalSoundboardPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  folders: [],
  showStatusBar: true,
  defaultVolume: 0.5,
  autoLoop: false
};
var LocalSoundboardPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.statusBarItem = null;
    this.statusBarAudio = [];
  }
  async onload() {
    await this.loadSettings();
    this.registerMarkdownCodeBlockProcessor("local-soundboard", this.processLocalSoundboard.bind(this));
    this.addSettingTab(new LocalSoundboardSettingTab(this.app, this));
    this.addRibbonIcon("folder-sync", "Refresh Local Soundboard", () => {
      this.refreshPlugin();
    });
    this.addCommand({
      id: "refresh-soundboard",
      name: "Refresh Local Soundboard",
      callback: () => {
        this.refreshPlugin();
      }
    });
    this.setupStatusBar();
  }
  onunload() {
    if (this.statusBarItem) {
      this.statusBarItem.remove();
    }
  }
  async loadSettings() {
    const loadedSettings = await this.loadData();
    this.settings = Object.assign({}, DEFAULT_SETTINGS, loadedSettings);
    if (!Array.isArray(this.settings.folders)) {
      this.settings.folders = DEFAULT_SETTINGS.folders;
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.updateStatusBar();
  }
  refreshPlugin() {
    new import_obsidian.Notice("Refreshing Local Soundboard...");
    this.stopAllAudio();
    if (this.statusBarItem) {
      this.statusBarItem.remove();
      this.statusBarItem = null;
    }
    if (this.settings.showStatusBar) {
      this.setupStatusBar();
    }
    new import_obsidian.Notice("Local Soundboard refreshed successfully!");
  }
  stopAllAudio() {
    if (this.statusBarAudio && Array.isArray(this.statusBarAudio)) {
      this.statusBarAudio.forEach((audio) => {
        audio.pause();
        audio.currentTime = 0;
      });
    }
  }
  setupStatusBar() {
    if (!this.settings.showStatusBar) {
      return;
    }
    this.statusBarItem = this.addStatusBarItem();
    this.updateStatusBar();
  }
  updateStatusBar() {
    if (!this.statusBarItem || !this.settings.showStatusBar) {
      return;
    }
    this.statusBarItem.empty();
    this.statusBarItem.addClass("local-soundboard-status");
    const container = this.statusBarItem.createDiv({ cls: "soundboard-status-container" });
    if (this.statusBarAudio && Array.isArray(this.statusBarAudio)) {
      this.statusBarAudio.forEach((audio) => audio.pause());
    }
    this.statusBarAudio = [];
    if (Array.isArray(this.settings.folders)) {
      this.settings.folders.forEach((folder, index) => {
        this.createFolderAudioPlayer(container, folder, index);
      });
    }
    this.createRefreshButton(container);
  }
  async updateAudioSelector(audioSelect, folderPath) {
    try {
      const audioFiles = await this.getAudioFilesFromFolder(folderPath);
      audioSelect.innerHTML = "";
      audioSelect.createEl("option", {
        text: "\u{1F3B6} Select Audio",
        value: ""
      });
      audioFiles.forEach((file) => {
        audioSelect.createEl("option", {
          text: file.basename,
          value: file.path
        });
      });
      audioSelect.removeAttribute("disabled");
    } catch (error) {
      console.error("Error loading audio files:", error);
      audioSelect.innerHTML = "";
      audioSelect.createEl("option", {
        text: "\u274C Error loading files",
        value: ""
      });
    }
  }
  createFolderAudioPlayer(container, folder, folderIndex) {
    const folderContainer = container.createDiv({ cls: "folder-status-container" });
    const selectorContainer = folderContainer.createDiv({ cls: "status-bar-selector-control" });
    const folderIconEl = selectorContainer.createEl("div", { cls: "status-bar-folder-icon" });
    if (folder.icon) {
      (0, import_obsidian.setIcon)(folderIconEl, folder.icon);
    } else {
      (0, import_obsidian.setIcon)(folderIconEl, "folder");
    }
    const audioSelect = selectorContainer.createEl("select", {
      cls: "audio-selector-small audio-selector-hidden"
    });
    audioSelect.createEl("option", { text: folder.name, value: "" });
    selectorContainer.addEventListener("mouseenter", () => {
      audioSelect.classList.remove("audio-selector-hidden");
    });
    selectorContainer.addEventListener("mouseleave", () => {
      audioSelect.classList.add("audio-selector-hidden");
    });
    const audioPlayerContainer = folderContainer.createDiv({ cls: "status-bar-audio-player-small" });
    const audioEl = audioPlayerContainer.createEl("audio", {
      attr: {
        preload: "none",
        ...folder.loop ? { loop: "true" } : {}
      },
      cls: "status-bar-audio-element"
    });
    const volumeControlContainer = audioPlayerContainer.createDiv({
      cls: "status-bar-volume-control"
    });
    const soundIcon = volumeControlContainer.createEl("div", {
      cls: "status-bar-sound-icon"
    });
    (0, import_obsidian.setIcon)(soundIcon, "volume-2");
    const volumeSlider = volumeControlContainer.createEl("input", {
      cls: "status-bar-volume-slider-small status-bar-volume-slider-hidden",
      attr: {
        type: "range",
        min: "0",
        max: "1",
        step: "0.1",
        value: this.settings.defaultVolume.toString(),
        orient: "vertical"
      }
    });
    const playButton = audioPlayerContainer.createEl("button", {
      cls: "status-bar-play-button-small play-state",
      attr: { type: "button" }
    });
    playButton.textContent = "";
    audioEl.volume = this.settings.defaultVolume;
    let isPlaying = false;
    playButton.addEventListener("click", () => {
      if (isPlaying) {
        audioEl.pause();
        audioEl.currentTime = 0;
        playButton.removeClass("pause-state");
        playButton.addClass("play-state");
        isPlaying = false;
        audioSelect.value = "";
      } else {
        audioEl.play();
        playButton.removeClass("play-state");
        playButton.addClass("pause-state");
        isPlaying = true;
      }
    });
    volumeSlider.addEventListener("input", () => {
      const volume = parseFloat(volumeSlider.value);
      audioEl.volume = volume;
    });
    volumeControlContainer.addEventListener("mouseenter", () => {
      volumeSlider.classList.remove("status-bar-volume-slider-hidden");
    });
    volumeControlContainer.addEventListener("mouseleave", () => {
      volumeSlider.classList.add("status-bar-volume-slider-hidden");
    });
    audioEl.addEventListener("ended", () => {
      if (!folder.loop) {
        playButton.removeClass("pause-state");
        playButton.addClass("play-state");
        isPlaying = false;
        audioSelect.value = "";
      }
    });
    this.loadAudioFilesForFolder(audioSelect, audioEl, folder.path);
    audioSelect.addEventListener("change", (e) => {
      const target = e.target;
      if (target.value) {
        audioEl.src = this.app.vault.adapter.getResourcePath(target.value);
        audioEl.load();
        audioEl.play().catch((error) => {
          console.error("Error playing audio:", error);
        });
        playButton.removeClass("play-state");
        playButton.addClass("pause-state");
        isPlaying = true;
      }
    });
    this.statusBarAudio.push(audioEl);
  }
  createRefreshButton(container) {
    const refreshContainer = container.createDiv({ cls: "status-bar-refresh-container" });
    const refreshButton = refreshContainer.createEl("button", {
      cls: "status-bar-refresh-button",
      attr: {
        type: "button",
        "aria-label": "Refresh Local Soundboard"
      }
    });
    const refreshIconContainer = refreshButton.createDiv({ cls: "refresh-icon-container" });
    (0, import_obsidian.setIcon)(refreshIconContainer, "folder-sync");
    refreshButton.addEventListener("click", () => {
      this.refreshPlugin();
    });
  }
  async loadAudioFilesForFolder(audioSelect, audioEl, folderPath) {
    try {
      const audioFiles = await this.getAudioFilesFromFolder(folderPath);
      audioFiles.forEach((file) => {
        audioSelect.createEl("option", {
          text: file.basename,
          value: file.path
        });
      });
    } catch (error) {
      console.error("Error loading audio files:", error);
      audioSelect.createEl("option", {
        text: "\u274C Error",
        value: ""
      });
    }
  }
  removeAudioPlayer(container) {
    const existingPlayers = container.querySelectorAll(".status-bar-audio-player-small");
    existingPlayers.forEach((player) => player.remove());
    if (this.statusBarAudio && Array.isArray(this.statusBarAudio)) {
      this.statusBarAudio.forEach((audio) => audio.pause());
    }
    this.statusBarAudio = [];
  }
  insertSoundboardBlock(folderPath, audioFilePath) {
    var _a;
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (activeView) {
      const editor = activeView.editor;
      const cursor = editor.getCursor();
      let block = `\`\`\`local-soundboard
folder: ${folderPath}`;
      if (audioFilePath) {
        const fileName = ((_a = audioFilePath.split("/").pop()) == null ? void 0 : _a.replace(/\.[^/.]+$/, "")) || "";
        block += `
title: ${fileName}`;
      }
      block += "\n```\n";
      editor.replaceRange(block, cursor);
      editor.setCursor(cursor.line + block.split("\n").length, 0);
    }
  }
  async processLocalSoundboard(source, el, ctx) {
    const container = el.createDiv({ cls: "local-soundboard-container" });
    const attributes = this.parseCodeBlockAttributes(source.trim());
    const folderPath = attributes.folder;
    if (!folderPath) {
      container.createEl("p", { text: 'Please specify a "folder" attribute with the folder path.' });
      container.createEl("pre", { text: "Example:\nfolder: Audio/SFX\ntitle: Sound Effects\nloop: true" });
      return;
    }
    const shouldLoop = attributes.loop === "true";
    let title;
    if (attributes.title) {
      title = attributes.title;
    } else {
      title = `Soundboard: ${folderPath}`;
    }
    const headerEl = container.createEl("h4", { cls: "soundboard-header" });
    if (attributes.icon) {
      const iconEl = headerEl.createSpan({ cls: "soundboard-icon" });
      (0, import_obsidian.setIcon)(iconEl, attributes.icon);
      headerEl.createSpan({ text: ` ${title}` });
    } else {
      headerEl.setText(title);
    }
    try {
      const audioFiles = await this.getAudioFilesFromFolder(folderPath);
      if (audioFiles.length === 0) {
        container.createEl("p", { text: "No audio files found in the specified folder." });
        return;
      }
      const audioContainer = container.createDiv({ cls: "status-bar-audio-player-small" });
      const selectorContainer = audioContainer.createDiv({ cls: "status-bar-selector-control" });
      const folderIconEl = selectorContainer.createEl("div", { cls: "status-bar-folder-icon" });
      if (attributes.icon) {
        (0, import_obsidian.setIcon)(folderIconEl, attributes.icon);
      } else {
        (0, import_obsidian.setIcon)(folderIconEl, "folder");
      }
      const audioSelect = selectorContainer.createEl("select", {
        cls: "audio-selector-small audio-selector-hidden"
      });
      audioSelect.createEl("option", { text: title, value: "" });
      selectorContainer.addEventListener("mouseenter", () => {
        audioSelect.classList.remove("audio-selector-hidden");
      });
      selectorContainer.addEventListener("mouseleave", () => {
        audioSelect.classList.add("audio-selector-hidden");
      });
      audioFiles.forEach((file) => {
        audioSelect.createEl("option", {
          text: file.basename,
          value: file.path
        });
      });
      const audioEl = audioContainer.createEl("audio", {
        attr: {
          preload: "none",
          ...shouldLoop ? { loop: "true" } : {}
        },
        cls: "status-bar-audio-element"
      });
      const volumeControlContainer = audioContainer.createDiv({
        cls: "status-bar-volume-control"
      });
      const soundIcon = volumeControlContainer.createEl("div", {
        cls: "status-bar-sound-icon"
      });
      (0, import_obsidian.setIcon)(soundIcon, "volume-2");
      const volumeSlider = volumeControlContainer.createEl("input", {
        cls: "status-bar-volume-slider-small status-bar-volume-slider-hidden",
        attr: {
          type: "range",
          min: "0",
          max: "1",
          step: "0.1",
          value: "1",
          orient: "vertical"
        }
      });
      const playButton = audioContainer.createEl("button", {
        cls: "status-bar-play-button-small play-state",
        attr: { type: "button" }
      });
      playButton.textContent = "";
      audioEl.volume = 1;
      let isPlaying = false;
      playButton.addEventListener("click", () => {
        if (isPlaying) {
          audioEl.pause();
          audioEl.currentTime = 0;
          playButton.removeClass("pause-state");
          playButton.addClass("play-state");
          isPlaying = false;
          audioSelect.value = "";
        } else {
          audioEl.play();
          playButton.removeClass("play-state");
          playButton.addClass("pause-state");
          isPlaying = true;
        }
      });
      volumeSlider.addEventListener("input", () => {
        const volume = parseFloat(volumeSlider.value);
        audioEl.volume = volume;
      });
      volumeControlContainer.addEventListener("mouseenter", () => {
        volumeSlider.classList.remove("status-bar-volume-slider-hidden");
      });
      volumeControlContainer.addEventListener("mouseleave", () => {
        volumeSlider.classList.add("status-bar-volume-slider-hidden");
      });
      audioEl.addEventListener("ended", () => {
        if (!shouldLoop) {
          playButton.removeClass("pause-state");
          playButton.addClass("play-state");
          isPlaying = false;
          audioSelect.value = "";
        }
      });
      audioSelect.addEventListener("change", (e) => {
        const target = e.target;
        if (target.value) {
          audioEl.src = this.app.vault.adapter.getResourcePath(target.value);
          audioEl.load();
          audioEl.play().catch((error) => {
            console.error("Error playing audio:", error);
          });
          playButton.removeClass("play-state");
          playButton.addClass("pause-state");
          isPlaying = true;
        }
      });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      container.createEl("p", {
        text: `Error loading audio files: ${errorMessage}`,
        cls: "error-message"
      });
    }
  }
  async getAudioFilesFromFolder(folderPath) {
    const audioExtensions = ["mp3", "wav", "ogg", "webm", "m4a", "flac", "aac"];
    const files = [];
    try {
      const folder = this.app.vault.getAbstractFileByPath(folderPath);
      if (!folder || folder instanceof import_obsidian.TFile) {
        throw new Error(`Folder "${folderPath}" not found`);
      }
      const allFiles = this.app.vault.getAllLoadedFiles();
      for (const file of allFiles) {
        if (file instanceof import_obsidian.TFile && file.path.startsWith(folderPath) && audioExtensions.indexOf(file.extension.toLowerCase()) !== -1) {
          files.push(file);
        }
      }
    } catch (error) {
      console.error("Error accessing folder:", error);
      throw error;
    }
    return files.sort((a, b) => a.name.localeCompare(b.name));
  }
  getAudioMimeType(extension) {
    const mimeTypes = {
      "mp3": "audio/mpeg",
      "wav": "audio/wav",
      "ogg": "audio/ogg",
      "webm": "audio/webm",
      "m4a": "audio/mp4",
      "flac": "audio/flac",
      "aac": "audio/aac"
    };
    return mimeTypes[extension.toLowerCase()] || "audio/*";
  }
  parseCodeBlockAttributes(content) {
    const attributes = {};
    if (!content.trim()) {
      return attributes;
    }
    const lines = content.split("\n").map((line) => line.trim()).filter((line) => line);
    for (const line of lines) {
      const match = line.match(/^(\w+):\s*(.+)$/);
      if (match && match[1] && match[2]) {
        const key = match[1];
        const value = match[2];
        attributes[key] = value.trim();
      }
    }
    return attributes;
  }
};
var LocalSoundboardSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Local Soundboard Settings" });
    containerEl.createEl("h3", { text: "Status Bar" });
    new import_obsidian.Setting(containerEl).setName("Show Status Bar").setDesc("Display folder selector in status bar for quick access").addToggle((toggle) => toggle.setValue(this.plugin.settings.showStatusBar).onChange(async (value) => {
      this.plugin.settings.showStatusBar = value;
      await this.plugin.saveSettings();
      if (value) {
        this.plugin.setupStatusBar();
      } else if (this.plugin.statusBarItem) {
        this.plugin.statusBarItem.remove();
        this.plugin.statusBarItem = null;
      }
    }));
    containerEl.createEl("h3", { text: "Folder Management" });
    const folderContainer = containerEl.createDiv({ cls: "folder-management-container" });
    this.displayFolders(folderContainer);
    const buttonsContainer = containerEl.createDiv({ cls: "folder-buttons-container" });
    const addFolderBtn = buttonsContainer.createEl("button", {
      cls: "mod-cta"
    });
    (0, import_obsidian.setIcon)(addFolderBtn, "plus");
    const globalSaveBtn = buttonsContainer.createEl("button", {
      cls: "mod-cta"
    });
    (0, import_obsidian.setIcon)(globalSaveBtn, "save");
    addFolderBtn.addEventListener("click", () => {
      this.addNewFolder(folderContainer);
    });
    globalSaveBtn.addEventListener("click", async () => {
      await this.saveAllFolderChanges(folderContainer);
    });
    containerEl.createEl("h3", { text: "Default Settings" });
    new import_obsidian.Setting(containerEl).setName("Default Volume").setDesc("Default volume for new audio controls (0.1 - 1.0)").addSlider((slider) => slider.setLimits(0.1, 1, 0.1).setValue(this.plugin.settings.defaultVolume).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.defaultVolume = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Auto Loop").setDesc("Enable audio looping by default").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoLoop).onChange(async (value) => {
      this.plugin.settings.autoLoop = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Usage" });
    containerEl.createEl("p", {
      text: "Create soundboards in your notes by specifying the folder path directly:"
    });
    containerEl.createEl("pre", {
      text: "```local-soundboard\nfolder: Audio/SFX\nicon: zap\ntitle: Battle Sound Effects\nloop: true\n```"
    });
    containerEl.createEl("h4", { text: "Attributes" });
    const attributesList = containerEl.createEl("ul");
    attributesList.createEl("li").innerHTML = '<strong>folder</strong>: (required) Direct path to the audio folder relative to your vault root (e.g., "Audio/SFX")';
    attributesList.createEl("li").innerHTML = '<strong>icon</strong>: (optional) Lucide icon name to display before the title (e.g., "zap", "music", "volume-2")';
    attributesList.createEl("li").innerHTML = '<strong>title</strong>: (optional) Custom title for the soundboard (e.g., "Battle Sound Effects")';
    attributesList.createEl("li").innerHTML = '<strong>loop</strong>: (optional) Set to "true" to enable audio looping, "false" or omit to disable';
    containerEl.createEl("h4", { text: "Popular Folder Icons" });
    const iconsInfo = containerEl.createEl("p", {
      text: "Common Lucide icons for audio folders: "
    });
    iconsInfo.innerHTML += "<code>music</code>, <code>volume-2</code>, <code>radio</code>, <code>headphones</code>, <code>speaker</code>, <code>mic</code>, <code>trees</code> (ambient), <code>zap</code> (effects), <code>guitar</code>, <code>piano</code>, <code>drum</code>";
    containerEl.createEl("p").innerHTML = 'Find more icons at <a href="https://lucide.dev/icons/" target="_blank">lucide.dev/icons</a>';
    containerEl.createEl("h4", { text: "Supported Audio Formats" });
    const formatsList = containerEl.createEl("ul");
    formatsList.createEl("li").textContent = "MP3 (.mp3)";
    formatsList.createEl("li").textContent = "WAV (.wav)";
    formatsList.createEl("li").textContent = "OGG (.ogg)";
    formatsList.createEl("li").textContent = "WebM (.webm)";
    formatsList.createEl("li").textContent = "M4A (.m4a)";
    formatsList.createEl("li").textContent = "FLAC (.flac)";
    formatsList.createEl("li").textContent = "AAC (.aac)";
  }
  displayFolders(container) {
    container.empty();
    if (!Array.isArray(this.plugin.settings.folders) || this.plugin.settings.folders.length === 0) {
      container.createEl("p", {
        text: "No folders configured. Add folders to use the status bar selector.",
        cls: "setting-item-description"
      });
      return;
    }
    this.plugin.settings.folders.forEach((folder, index) => {
      const folderItem = container.createDiv({ cls: "folder-item" });
      const folderInfo = folderItem.createDiv({ cls: "folder-info" });
      const nameInput = folderInfo.createEl("input", {
        type: "text",
        value: folder.name,
        placeholder: "Folder name",
        cls: "folder-name-input"
      });
      const pathInput = folderInfo.createEl("input", {
        type: "text",
        value: folder.path,
        placeholder: "Folder path",
        cls: "folder-path-input"
      });
      const iconContainer = folderInfo.createDiv({ cls: "folder-icon-container" });
      const iconPreview = iconContainer.createEl("div", { cls: "folder-icon-preview" });
      if (folder.icon) {
        (0, import_obsidian.setIcon)(iconPreview, folder.icon);
      }
      const iconInput = iconContainer.createEl("input", {
        type: "text",
        value: folder.icon || "",
        placeholder: "Lucide icon name (e.g., music, volume-2)",
        cls: "folder-icon-input"
      });
      iconInput.addEventListener("input", () => {
        const iconName = iconInput.value.trim();
        iconPreview.empty();
        if (iconName) {
          try {
            (0, import_obsidian.setIcon)(iconPreview, iconName);
          } catch (error) {
            iconPreview.textContent = "\u274C";
          }
        }
      });
      const loopContainer = folderInfo.createDiv({ cls: "folder-loop-container" });
      const loopCheckbox = loopContainer.createEl("input", {
        attr: {
          type: "checkbox"
        },
        cls: "folder-loop-checkbox"
      });
      loopCheckbox.checked = folder.loop;
      const loopLabel = loopContainer.createEl("label", {
        text: "Loop audio",
        cls: "folder-loop-label"
      });
      loopLabel.setAttribute("for", `loop-${index}`);
      const actions = folderItem.createDiv({ cls: "folder-actions" });
      const deleteBtn = actions.createEl("button", {
        cls: "mod-warning"
      });
      (0, import_obsidian.setIcon)(deleteBtn, "trash-2");
      deleteBtn.addEventListener("click", async () => {
        this.plugin.settings.folders.splice(index, 1);
        await this.plugin.saveSettings();
        this.displayFolders(container);
      });
    });
  }
  addNewFolder(container) {
    const newFolderItem = container.createDiv({ cls: "folder-item new-folder" });
    const folderInfo = newFolderItem.createDiv({ cls: "folder-info" });
    const nameInput = folderInfo.createEl("input", {
      type: "text",
      placeholder: "Folder name",
      cls: "folder-name-input"
    });
    const pathInput = folderInfo.createEl("input", {
      type: "text",
      placeholder: "Folder path",
      cls: "folder-path-input"
    });
    const iconContainer = folderInfo.createDiv({ cls: "folder-icon-container" });
    const iconPreview = iconContainer.createEl("div", { cls: "folder-icon-preview" });
    const iconInput = iconContainer.createEl("input", {
      type: "text",
      placeholder: "Lucide icon name (e.g., music, volume-2)",
      cls: "folder-icon-input"
    });
    iconInput.addEventListener("input", () => {
      const iconName = iconInput.value.trim();
      iconPreview.empty();
      if (iconName) {
        try {
          (0, import_obsidian.setIcon)(iconPreview, iconName);
        } catch (error) {
          iconPreview.textContent = "\u274C";
        }
      }
    });
    const actions = newFolderItem.createDiv({ cls: "folder-actions" });
    const addBtn = actions.createEl("button", {
      text: "Add",
      cls: "mod-cta"
    });
    const cancelBtn = actions.createEl("button", {
      text: "Cancel"
    });
    addBtn.addEventListener("click", async () => {
      const name = nameInput.value.trim();
      const path = pathInput.value.trim();
      const icon = iconInput.value.trim();
      if (name && path) {
        this.plugin.settings.folders.push({
          name,
          path,
          loop: false,
          icon: icon || void 0
        });
        await this.plugin.saveSettings();
        this.displayFolders(container);
      }
    });
    cancelBtn.addEventListener("click", () => {
      this.displayFolders(container);
    });
    nameInput.focus();
  }
  async saveAllFolderChanges(container) {
    const folderItems = container.querySelectorAll(".folder-item");
    const updatedFolders = [];
    folderItems.forEach((folderItem, index) => {
      const nameInput = folderItem.querySelector(".folder-name-input");
      const pathInput = folderItem.querySelector(".folder-path-input");
      const iconInput = folderItem.querySelector(".folder-icon-input");
      const loopCheckbox = folderItem.querySelector(".folder-loop-checkbox");
      if (nameInput && pathInput && loopCheckbox) {
        const existingFolder = this.plugin.settings.folders[index];
        if (existingFolder) {
          const iconValue = iconInput == null ? void 0 : iconInput.value.trim();
          updatedFolders.push({
            name: nameInput.value.trim() || existingFolder.name,
            path: pathInput.value.trim() || existingFolder.path,
            loop: loopCheckbox.checked,
            icon: iconValue || void 0
          });
        }
      }
    });
    this.plugin.settings.folders = updatedFolders;
    await this.plugin.saveSettings();
    const notice = new import_obsidian.Notice("All folder configurations saved successfully!");
  }
};
